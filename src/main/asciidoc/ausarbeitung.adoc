= Language Design
Ariel Simulevski <ariel@simulevski.at>
v0.1, 2018-12-24
:example-caption!:
:media: prepress
:icons: font

ifdef::backend-pdf[:imagesoutdir: ../../../build/asciidoc/{backend}/images]
ifdef::backend-pdf[:imagesdir: ../../../build/asciidoc/{backend}/images]

// this renders a dynamic table of content
:toc:

== Abstract

Here one should write the abstract of the paper. It is usually between 1 and 3 paragraphs long.

== Introduction

The list of general purpose programming languages has been growing recently. With it, a staggering amount of immature and, generally, out of place languages. Of course, there are some really good new languages (Kotlin, Go, Rust), but others (such as Solidity, JavaScript or Python) have features or design flaws that make them seem out of place or unliked by some.

Language design and intelligent language features are now more important than they've ever been. With the amount of languages out there, creating a new language with features that sets it apart and doesn't make it seem "ugly" or "irrelevant" is quite a challenge. This paper will aim to introduce you into language- and language-feature design.

<<<

=== What is a programming language?

What many people don't understand is, that a programming language is nothing more than an agreement. An agreement between you, the programmer, and the creator of given language, that states how a program in the given language has to be written (how the instructions are called, how to write functions, loops, declare variables etc.) so that the runtime understands it.

Source code itself is also nothing special. It is just bytes in a, in most cases, UTF-8 encoded text file, which are
arranged in a manner so that they form commands which the runtime of a given language can understand.

Nearly everything can be considered a language. If we define a language so that

* the character `*` followed by an identifier, creates a variable
* the character `+` followed by an identifier, adds one to a variable
* the characters `:=` preceeded by an identifier and followed by a numeric value or an identifier, assigned a value to a variable
* the characters `+=` preceeded by an identifier and followed by a numeric value or an identifier, added a value to a variable
* the character `=` preceeded by an identifier and followed by an identifier, compares two variables
* an identifier followed by the character `:`, creates a label

<<<
and

* the character `<` followed by a lable name, jumps to a label if the last comparison evaluated to `1`

this:

``` coffeescript

*a
a:=0

*b
b:=0

loop:
b=10
< next

a+=b
+b

1=1
< loop
next:

```

would be valid source code (in fact, the language could even be considered <<What is Turing completeness?,Turing complete>>). We won't be able to execute it, of course, as we don't have a runtime for that language, but it is a defined language, nonetheless.

=== Compiled vs Transpiled vs Interpreted

For a program written in a language to be executed, you need a runtime. A runtime is the basic execution model of any implementation of any language.

[NOTE]
====
When I speak of runtime levels, I refer to code that runs closer, or further away (in means of abstraction) from the hardware. This, in turn, means that a system has to have a concept of "closer or further from hardware".
====
<<<
==== Compiled

A compiler scans the entire source code and translates it into lower level code. That doesn't always mean converting the source code into machine code, but rather, translating the code into a very primitive version of itself. Sometimes, code is compiled into bytecode (primitive code than can be executed in a virtual machine).

===== Examples
* *GCC* <<gcc>>: C{plus}{plus} -> Machine code
* *Roslyn* <<roslyn>>: C# -> CIL (Common Intermediate Language, C# bytecode)
* *javac* <<javac>>: Java -> Java Bytecode

==== Transpiled

A transpiler also scans the entire source code, but, instead of translating it into lower level code, the transpiler translates it into another language on the same execution level. This language can than be compiled, transpiled or interpreted itself.

===== Examples

* *Babel* <<babeljs>>: ES6 -> JavaScript
* *CoffeeScript* <<coffeescript>>: CoffeeScript -> JavaScript
* *emscripten* <<emscripten>>: LLVM -> JavaScript

==== Interpreted

An interpreter is practically not comparable to a compiler or a transpiler. Instead of translating the language, an interpreter goes through the source code, line-by-line, and tries to figure out what the program is supposed to do as it goes.

<<<
In some cases, the interpreter processes bytecode instead of source code. An interpreter that interprets bytecode is called a virtual machine (or VM for short). When an interpreter processes bytecode, it first needs to compile whatever language it interprets into the bytecode (which means that such an interpreter always has a compiler in its execution pipeline).

An example for that process would be CPython <<cpython>>.

[graphviz, dot-example,svg]
----
digraph g {
    ".py - Python source code" -> ".pyc - Python bytecode" -> ".pyc executed in CPython VM"
}
----

In recent years, people started to implement JIT (or Just-in-Time) compilers into their interpreters.

These JIT compilers can figure out what parts of a program are resource-intensive and then compile these parts of the program (at runtime, meaning while a program is being executed), from bytecode into machine code. Everything else is still being executed in a VM. Whenever the VM needs to call code that has been "JITed", it calls those, now native, functions.

=== Definition vs Implementation

Before we start, we first need to understand the difference between language definition and language implementation. These two are often confused and thus, people say things like "C{plus}{plus} is a fast language" or "Python is really slow".

But languages themselves, have nothing to do with speed. Language implementations do. Of course, certain languages tend to encourage certain runtime systems, while language constructs of others might make it harder to have a faster runtime. But, in theory, every language can be as fast as any other.

One could make an interpreted version of C{plus}{plus}, which would be slower than the reference implementation (GCC, compiled). Same for Python. It would be, theoretically, possible to write a Python compiler which would have significantly faster runtime performance than its reference implementation (CPython, interpreted).

In fact, there are many non-reference implementations of languages out there (like the Just-in-Time compiled Python implementation, PyPy <<pypy>>, or the C++ interpreter Cling <<cling>>)

=== What is Turing completeness?

For us to understand Turing completeness, we need to go back in time. To the 1940s to be precise. Back then, the second world war was at its hiatus, the Nazis seemed undefeatable. No one could predict their strategy. The only way to do it was cracking their encryption algorithm, the "ENIGMA". The challenge seemed so completely out of scope that for a while, British intelligence tried to just guess what the code might be. Until Alan Turing came along and created a computational device that was able to figure out the encryption keys of the "ENIGMA".

Fascinated by the idea of a universal computing device, Turing first turned his attention to designing a general purpose computing machine in 1936. This was when Turing first formulated the idea of the "Universal Computing Machine" <<turing1>> (now simply known as a "Turing machine"). A mathematical model that defines an abstract computation device. The machine works by modifying symbols on a strip of tape according to opcodes (a table of rules). Even thogh the model was simple, it could, in theory, simulate any given mathematical algorithm.

Turing wasn't the only one who formulated such an idea. In 1931, Kurt Gödel had already published a similar mathematical formalism in his paper on the "Gödel's incompleteness theorems" <<goedel1>>.

A Turing complete language describes a language that has, at least, the same computational capabilities as Alan Turing had with his "Turing machine". To put it simply:

NOTE: A turing complete language can emulate a universal Turing machine.

That also means that two computational devices P and Q are equal if P can simulate Q and Q can simulate P. This is called Turing equivalence.

== Different types of programming languages

Before we get into actually creating a programming language, we need to know what kind of language we want. We can generally differentiate into three different kinds of programming languages:

NOTE: A programming paradigm is a style of programming. It is a way of thinking about a solution. Programming paradigms do not refer to a specific language, but rather to a type of programming language (to a way to program).

=== Procedural

According to most people, procedural programming is the most basic form programming paradigm. In a procedural language, the programmer describes what the program is supposed to do step-by-step. There are basic procedures, known as subroutines or functions, and more often that not, one will be able to define data structures in a procedural language, but that is as feature-rich as it gets.

==== Examples

* C
* Fortran
* Bash

=== Object oriented

Object oriented programming, OOP for short, builds on top of procedural programming. The central programming paradigm in OOP is based on the concepts of objects. These objects can contain data or procedures. When a procedure is associated with an object, it is referred to as a method.

==== Examples

* C{plus}{plus}
* Java
* Python

=== Functional

Functional programming aims to model a program as the evaluation of mathematical functions. Generally, state-changing and mutability of data is avoided. One of the central programming paradigms is currying <<currying>>. Currying, which was invented by Moses Schönfinkel in 1928 and named after Haskell Brooks Curry, a famous mathematician, is about passing data to a function to generate another function as a result. This resulting function can then be used to do other calculations. Since mutability and state-changing is avoided, functions should not have any shared state or side-effects.

==== Examples

* F#
* Haskell
* Clojure

<<<
== What makes a language a...

=== ...good language?

Content of chapter 2.

=== ...bad language?

Content of chapter 3.

== How to write good languages

Content of chapter 4.

== The three rules of good language design

=== Simplicity

=== Consistency

=== Explicitness

We all love not having to write a lot of code and just letting the runtime guess what we could have meant,
but being in-explicit, just for the sake of writing code that has a couple fewer bytes, is no good.

A compiler could, in theory, differentiate between an `=` in an assignment and as an equality comparison operator.

That means, that a language could exist where this:

``` python
a = 10

if a = 10:
    print("a is 10")
```

is valid code. And with a decent enough recursive descent parser, we'd be able to make something like this valid. Which certainly doesn't mean that we should.

== Adding a feature to a language

=== Feature is consistent

=== Feature is inconsistent but fits in the languages look and feel

=== Feature is inconsistent and doesn't fit

== Writing our own mini language

Content of chapter 6.

=== Definiton

Content of chapter 7.

=== Lexer

Content of chapter 8.

=== Parser

Content of chapter 9.

=== Setup

For this example, I'd recomend using a UNIX based or unixoid machine. I'll be using Ubuntu 18.04.1 LTS 64bit
for both the setup and the programming part. My editor of choice will be VSCode with the following extensions:

* -
* -

==== Packages

``` shell

sudo apt install flex bison make gcc g++ -y

```

== Lex/Yacc hands on

Content of chapter 11.

== A simple interpreter

Content of chapter 12.

== Summary

Here one should write the summary of the paper. It's usually between 1 and 5 paragraphs long.

<<<

[bibliography]
== References

- [[[gcc,1]]] GCC, the GNU Compiler Collection - GNU Project - Free Software Foundation (FSF): https://gcc.gnu.org/
- [[[roslyn,2]]] dotnet/roslyn: The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs: https://github.com/dotnet/roslyn
- [[[javac,3]]] javac - Wikipedia: https://en.wikipedia.org/wiki/Javac
- [[[babeljs,4]]] Babel · The compiler for next generation JavaScript: https://babeljs.io/
- [[[coffeescript,5]]] CoffeeScript: https://coffeescript.org/
- [[[emscripten,6]]] kripken/emscripten: Emscripten: An LLVM-to-JavaScript Compiler: https://github.com/kripken/emscripten
- [[[cpython,7]]] python/cpython: The Python programming language: https://github.com/python/cpython
- [[[pypy,8]]] PyPy - Welcome to PyPy: https://pypy.org/
- [[[cling,9]]] Cling: https://cdn.rawgit.com/root-project/cling/master/www/index.html
- [[[turing1,10]]] Turing, A. M. (1936). https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf[On Computable Numbers, With an Application to the Entscheidungsproblem]
- [[[goedel1,11]]] Gödel, K. (1931). http://www.w-k-essler.de/pdfs/goedel.pdf[Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme, I], Monatshefte für Mathematik und Physik, v. 38 n. 1, pp. 173–198.
- [[[currying,12]]] Schönfinkel, M. (1928). http://www.cip.ifi.lmu.de/~langeh/test/1924%20-%20Schoenfinkel%20-%20Ueber%20die%20Bausteine%20der%20mathematischen%20Logik.pdf[Über die Bausteine der mathematischen Logik], Mathematische Annalen, v. 92 n. 1, pp. 305-316