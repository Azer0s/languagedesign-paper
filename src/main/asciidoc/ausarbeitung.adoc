= Language Design
Ariel Simulevski <ariel@simulevski.at>
v0.1, 2018-12-24
:example-caption!:
:media: prepress
:icons: font
:source-highlighter: rouge

ifdef::backend-pdf[:imagesoutdir: ../../../build/asciidoc/{backend}/images]
ifdef::backend-pdf[:imagesdir: ../../../build/asciidoc/{backend}/images]

// this renders a dynamic table of content
:toc:

== Abstract

Here one should write the abstract of the paper. It is usually between 1 and 3 paragraphs long.

== Introduction

The list of general purpose programming languages has been growing recently. With it, a staggering amount of immature and, generally, out of place languages. Of course, there are some really good new languages (Kotlin, Go, Rust), but others (such as Solidity, JavaScript or Python) have features or design flaws that make them seem out of place or unliked by some.

Language design and intelligent language features are now more important than they've ever been. With the amount of languages out there, creating a new language with features that sets it apart and doesn't make it seem "ugly" or "irrelevant" is quite a challenge. This paper will aim to introduce you into language- and language-feature design.

=== What is a programming language?

What many people don't understand is, that a programming language is nothing more than an agreement. An agreement between you, the programmer, and the creator of given language, that states how a program in the given language has to be written (how the instructions are called, how to write functions, loops, declare variables etc.) so that the runtime understands it.

Source code itself is also nothing special. It is just bytes in a, in most cases, UTF-8 encoded text file, which are
arranged in a manner so that they form commands which the runtime of a given language can understand.

Nearly everything can be considered a language. If we define a language so that

* the character `*` followed by an identifier, creates a variable
* the character `+` followed by an identifier, adds one to a variable
* the characters `:=` preceeded by an identifier and followed by a numeric value or an identifier, assigned a value to a variable
* the characters `+=` preceeded by an identifier and followed by a numeric value or an identifier, added a value to a variable
* the character `=` preceeded by an identifier and followed by an identifier, compares two variables
* an identifier followed by the character `:`, creates a label

and

* the character `<` followed by a lable name, jumps to a label if the last comparison evaluated to `1`

this:

``` coffeescript

*a
a:=0

*b
b:=0

loop:
b=10
< next

a+=b
+b

1=1
< loop
next:

```

would be valid source code (in fact, the language could even be considered <<What is Turing completeness?,Turing complete>>). We won't be able to execute it, of course, as we don't have a runtime for that language, but it is a defined language, nonetheless.

=== Compiled vs Transpiled vs Interpreted

For a program written in a language to be executed, you need a runtime. A runtime is the basic execution model of any implementation of any language.

[NOTE]
====
When I speak of runtime levels, I refer to code that runs closer, or further away (in means of abstraction) from the hardware. This, in turn, means that a system has to have a concept of "closer or further from hardware".
====

==== Compiled

A compiler scans the entire source code and translates it into lower level code. That doesn't always mean converting the source code into machine code, but rather, translating the code into a very primitive version of itself. Sometimes, code is compiled into bytecode (primitive code than can be executed in a virtual machine).

===== Examples
* *GCC* <<gcc>>: C{plus}{plus} -> Machine code
* *Roslyn* <<roslyn>>: C# -> CIL (Common Intermediate Language, C# bytecode)
* *javac* <<javac>>: Java -> Java Bytecode

==== Transpiled

A transpiler also scans the entire source code, but, instead of translating it into lower level code, the transpiler translates it into another language on the same execution level. This language can than be compiled, transpiled or interpreted itself.

===== Examples

* *Babel* <<babeljs>>: ES6 -> JavaScript
* *CoffeeScript* <<coffeescript>>: CoffeeScript -> JavaScript
* *emscripten* <<emscripten>>: LLVM -> JavaScript

==== Interpreted

An interpreter is practically not comparable to a compiler or a transpiler. Instead of translating the language, an interpreter goes through the source code, line-by-line, and tries to figure out what the program is supposed to do as it goes.

In some cases, the interpreter processes bytecode instead of source code. An interpreter that interprets bytecode is called a virtual machine (or VM for short). When an interpreter processes bytecode, it first needs to compile whatever language it interprets into the bytecode (which means that such an interpreter always has a compiler in its execution pipeline).

An example for that process would be CPython <<cpython>>.

.Python source code to execution lifecycle
[graphviz, python-conversion,svg]
----
digraph g {
    ".py - Python source code" -> ".pyc - Python bytecode" -> ".pyc executed in CPython VM"
}
----

In recent years, people started to implement JIT (or Just-in-Time) compilers into their interpreters.

These JIT compilers can figure out what parts of a program are resource-intensive and then compile these parts of the program (at runtime, meaning while a program is being executed), from bytecode into machine code. Everything else is still being executed in a VM. Whenever the VM needs to call code that has been "JITed", it calls those, now native, functions.

=== Definition vs Implementation

Before we start, we first need to understand the difference between language definition and language implementation. These two are often confused and thus, people say things like "C{plus}{plus} is a fast language" or "Python is really slow".

But languages themselves, have nothing to do with speed. Language implementations do. Of course, certain languages tend to encourage certain runtime systems, while language constructs of others might make it harder to have a faster runtime. But, in theory, every language can be as fast as any other.

NOTE: The reference implementation is the implementation made by the creator of a language. It, usually, gets new language features first and is always compliant with the standard (because it is the standard).

One could make an interpreted version of C{plus}{plus}, which would be slower than the reference implementation (GCC, compiled). Same for Python. It would be, theoretically, possible to write a Python compiler which would have significantly faster runtime performance than its reference implementation (CPython, interpreted).

In fact, there are many non-reference implementations of languages out there (like the Just-in-Time compiled Python implementation, PyPy <<pypy>>, or the C++ interpreter Cling <<cling>>)

=== What is Turing completeness?

For us to understand Turing completeness, we need to go back in time. To the 1940s to be precise. Back then, the second world war was at its hiatus, the Nazis seemed undefeatable. No one could predict their strategy. The only way to do it was cracking their encryption algorithm, the "ENIGMA". The challenge seemed so completely out of scope that for a while, British intelligence tried to just guess what the code might be. Until Alan Turing came along and created a computational device that was able to figure out the encryption keys of the "ENIGMA".

Fascinated by the idea of a universal computing device, Turing first turned his attention to designing a general purpose computing machine in 1936. This was when Turing first formulated the idea of the "Universal Computing Machine" <<turing1>> (now simply known as a "Turing machine"). A mathematical model that defines an abstract computation device. The machine works by modifying symbols on a strip of tape according to opcodes (a table of rules). Even thogh the model was simple, it could, in theory, simulate any given mathematical algorithm.

Turing wasn't the only one who formulated such an idea. In 1931, Kurt Gödel had already published a similar mathematical formalism in his paper on the "Gödel's incompleteness theorems" <<goedel1>>.

A Turing complete language describes a language that has, at least, the same computational capabilities as Alan Turing had with his "Turing machine". To put it simply:

NOTE: A turing complete language can emulate a universal Turing machine.

That also means that two computational devices P and Q are equal if P can simulate Q and Q can simulate P. This is called Turing equivalence.

=== The EBNF (Extended Backus-Naur-Form)

//TODO

== Different types of programming languages

Before we get into actually creating a programming language, we need to know what kind of language we want. We can generally differentiate into three different kinds of programming languages:

NOTE: A programming paradigm is a style of programming. It is a way of thinking about a solution. Programming paradigms do not refer to a specific language, but rather to a type of programming language (to a way to program).

=== Procedural

According to most people, procedural programming is the most basic form programming paradigm. In a procedural language, the programmer describes what the program is supposed to do step-by-step. There are basic procedures, known as subroutines or functions, and more often that not, one will be able to define data structures in a procedural language, but that is as feature-rich as it gets.

==== Examples

* C
* Fortran
* Bash

=== Object oriented

Object oriented programming, OOP for short, builds on top of procedural programming. The central programming paradigm in OOP is based on the concepts of objects. These objects can contain data or procedures. When a procedure is associated with an object, it is referred to as a method.

==== Examples

* C{plus}{plus}
* Java
* Python

=== Functional

Functional programming aims to model a program as the evaluation of mathematical functions. Generally, state-changing and mutability of data is avoided. One of the central programming paradigms is currying <<currying>>. Currying, which was invented by Moses Schönfinkel in 1928 and named after Haskell Brooks Curry, a famous mathematician, is about passing data to a function to generate another function as a result. This resulting function can then be used to do other calculations. Since mutability and state-changing is avoided, functions should not have any shared state or side-effects.

==== Examples

* F#
* Haskell
* Clojure

== The three rules of good language design

//TODO

=== Simplicity

//TODO

=== Consistency

//TODO

=== Explicitness

We all love not having to write a lot of code and just letting the runtime guess what we could have meant,
but being in-explicit, just for the sake of writing code that has a couple fewer bytes, is no good.

A compiler could, in theory, differentiate between an `=` in an assignment and as an equality comparison operator.

That means, that a language could exist where this:

``` python
a = 10

if a = 10:
    print("a is 10")
```

is valid code. And with a decent enough recursive descent parser, we'd be able to make something like this valid. Which certainly doesn't mean that we should.

== How to write a programming language?

Now that we know the rules to good language design, and know what not to do when developing a programming language, we can start with writing our own little language.

=== Pre-requirements

Before we start writing your programming language, we need to ask ourselves some questions. This will make the process of conceptualizing features and actually developing our language easier and will give us a clear definition as to what we actually want to achieve.

==== Technical aspects

===== What kind of programming language is it?

It is generally agreed upon, that procedural languages are the easiest to develop. There are no classes, interfaces or other code abstractions (like polymorphism). Functional constructs, such as currying, are also not supported. Simply put: there are less features one has to support, thus, the language itself is not as complicated.

Object oriented or functional language are both harder to develop and to conceptualize, but are often far more powerful than procedural ones.

===== Is it compiled or interpreted?

The question, whether your language should be compiled or interpreted regards your reference implementation. While compiling tends to have greatly improved performance over interpreted languages, interpreting a language comes with higher flexibility.

For a reference implementation, interpreting a language makes more sense. Interpreters often have a bigger feature set and are easier to debug than compilers, thus making them better for trying out a language. footnote:[Personal opinion]

==== Non-technical aspects

===== Why are you writing it?

As mentioned in the introduction, the list of programming languages is nearly endless. There is a programming language for almost every use-case out there. So why write a new one?

There is no right or wrong to this question. The answer "Just for fun" is as correct as "Because I thougt of a new language feature that will revolutionize how we program". Nevertheless, it is of utmost importance that you ask yourself that. That is, because developing a programming language is all about focus. It is about focusing on the thing you want your language to do.

If your language is designed for a certain thing, trying to make it do something completely different will just complicate the issue and unless you're either really lucky or really good, you'll end up with something extremely complex.

===== Who are you writing it for?

Knowing your user base is always important. Whether you develop an online shop or a programming language doesn't really matter. What does matter is that you know who will be using your language. Writing a language for statistical computing, like R <<r>>, for instance, is something completely different from writing a general purpose programming language.

While R mostly used by students or scientists, a language like C# is mostly used by software engineers. R doesn't need to have the same enterprise capabilities like C# and C# doesn't need to have the same ability to express complicated mathematical formulae, like R does.

=== Developing a language

//TODO

==== Giving the language a name

//TODO

==== Defining the language

//TODO

==== Defining the feature set of the language

//TODO

== Adding a feature to a language

Adding features to a language is more complicated than it appears to be. Adding too many features might make the language cluttered and unusable. Certain features might not look right in the language (from an aesthetic standpoint, that is) and others might just not be technically possible.

To add a feature, we first need to define it. Say we want to add pipelines to the C# programming language.

We can't implement this feature by utilizing existing functionalities as there are no macros in C#, so we need to define a new operator. Let's take the well known `|>` operator from F#. Now that we know what we're going to add into our language, we need to write a basic EBNF for that.

``` ebnf
statements = { statement } ;
statement =  pipeline | ... ;
pipeline = statement, "|>", statement ;
```

With our EBNF ready, we need to write a code sample with our feature as the focus.

``` java

Console.ReadLine();
    |> File.ReadAllBytes
    |> SHA1.Create().ComputeHash
    |> BitConverter.ToString
    |> Console.WriteLine;

```

Before we implement our feature, we need to answer some questions.

.Flowgraph for implementing a new language feature
[graphviz,Design-feature-graph, svg]
----
digraph g {
    "Design feature" ->

    "Feature fits in the languages look and feel?"

    "Feature fits in the languages look and feel?" -> "Yes, it does" -> Implement
    "Feature fits in the languages look and feel?" -> "No, it does not" -> "Feature is necesary?"

    "Feature is necesary?" -> "Yes, it is" -> "Feature can be redesigned?"
    "Feature is necesary?" -> "No, but I want it" -> "Design feature"
    "Feature is necesary?" -> "No, it is not" -> "Discard feature"

    "Feature can be redesigned?" -> "Yes, it can" -> "Design feature"
    "Feature can be redesigned?" -> "No, it can not" -> "Implement"
}
----

For our new C# feature, this is fairly trivial. Our new language feature does, in fact, fit in the languages look and feel. Therefore, we can implement it.

If it didn't fit, we'd have to ask ourselves if the feature is necessary and if there is another way to solve the problem we're solving with this feature (even if said way is syntactly less pleasing). If that were the case, we could either discard the feature or redesign it.

If the feature was necessary, and can simply not be redesigned (this mostly happens because of other  design flaws in a language), we'd have to implement the feature to our best of knowledge and belief.

== Writing our own mini language

//TODO

=== Definiton

//TODO

=== Lexer

//TODO

=== Parser

//TODO

=== Setup

For this example, I'd recomend using a UNIX based or unixoid machine. I'll be using Ubuntu 18.04.1 LTS 64bit
for both the setup and the programming part. My editor of choice will be VSCode with the following extensions:

* EBNF Tools <<ebnftools>>
* Lex Flex Yacc Bison <<lexflexyaccbison>>

and

* C/C++ <<cppcode>>

==== Packages

``` shell

sudo apt install flex bison make gcc g++ -y

```

== Lex/Yacc hands on

//TODO

== A simple interpreter

//TODO

== Summary

Here one should write the summary of the paper. It's usually between 1 and 5 paragraphs long.

<<<

[bibliography]
== References

- [[[gcc,1]]] GCC, the GNU Compiler Collection - GNU Project - Free Software Foundation (FSF): https://gcc.gnu.org/
- [[[roslyn,2]]] dotnet/roslyn: The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs: https://github.com/dotnet/roslyn
- [[[javac,3]]] javac - Wikipedia: https://en.wikipedia.org/wiki/Javac
- [[[babeljs,4]]] Babel · The compiler for next generation JavaScript: https://babeljs.io/
- [[[coffeescript,5]]] CoffeeScript: https://coffeescript.org/
- [[[emscripten,6]]] kripken/emscripten: Emscripten: An LLVM-to-JavaScript Compiler: https://github.com/kripken/emscripten
- [[[cpython,7]]] python/cpython: The Python programming language: https://github.com/python/cpython
- [[[pypy,8]]] PyPy - Welcome to PyPy: https://pypy.org/
- [[[cling,9]]] Cling: https://cdn.rawgit.com/root-project/cling/master/www/index.html
- [[[turing1,10]]] Turing, A. M. (1936). https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf[On Computable Numbers, With an Application to the Entscheidungsproblem]
- [[[goedel1,11]]] Gödel, K. (1931). http://www.w-k-essler.de/pdfs/goedel.pdf[Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme, I], Monatshefte für Mathematik und Physik, v. 38 n. 1, pp. 173–198.
- [[[currying,12]]] Schönfinkel, M. (1928). http://www.cip.ifi.lmu.de/~langeh/test/1924%20-%20Schoenfinkel%20-%20Ueber%20die%20Bausteine%20der%20mathematischen%20Logik.pdf[Über die Bausteine der mathematischen Logik], Mathematische Annalen, v. 92 n. 1, pp. 305-316
- [[[r,13]]] R: The R Project for Statistical Computing: https://www.r-project.org/
- [[[ebnftools,14]]] EBNF Tools - Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=igochkov.vscode-ebnf
- [[[lexflexyaccbison,15]]] Lex Flex Yacc Bison - Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=faustinoaq.lex-flex-yacc-bison
- [[[cppcode,16]]] C/C++ - Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools